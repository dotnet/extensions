<Project>
  <Import Project="$([MSBuild]::GetPathOfFileAbove('Directory.Build.targets', '$(MSBuildThisFileDirectory)../'))" />

  <!--
    Template projects use <ProjectReference> items to:

    1. Ensure `build.cmd -vs AI` or `build.cmd -vs ProjectTemplates`
       results in the referenced project being included in the SDK.sln
       file, along with its transitive project references.

    2. Collect the Package ID and Version from the project for use in
       the template using the "GetProjectPackageVersion" target defined
       in /eng/MSBuild/Packaging.targets.

    This <ItemDefinitionGroup> must be defined in targets after
    Microsoft.Common.CurrentVersion.Targets  so that it can override the
    <ItemDefinitionGroup> defined there.

    - ReferenceOutputAssembly - don't pass to the compiler
    - Targets - use this target instead of the default GetTargetPath
    - SkipGetTargetFrameworkProperties - no need to handle multi-targeting
    - OutputItemType - the name of the item to output from the target
    - Private - false means don't copy to output directory, not private
  -->
  <ItemDefinitionGroup>
    <ProjectReference ReferenceOutputAssembly="false"
                      Targets="GetProjectPackageVersion"
                      SkipGetTargetFrameworkProperties="true"
                      OutputItemType="ProjectPackageVersion"
                      Private="false" />
  </ItemDefinitionGroup>

  <Target Name="_CleanProjectTemplates" BeforeTargets="Clean">
    <!-- Delete the GeneratedContent, Sandbox, and Snapshots artifacts folders when cleaning the template project -->
    <RemoveDir Directories="$([System.IO.Path]::Combine($(ArtifactsDir), 'ProjectTemplates', $(PackageId)))" />
  </Target>

  <!--
    Invoke this target before both "Build" and "Pack" for all template projects.
    This ensures the template content is generated during either a Build
  -->
  <Target Name="_GenerateTemplateContent" BeforeTargets="Build"
          DependsOnTargets="_ResolveTemplatePackageVersions;_ResolveTemplateContentPaths">

    <!--
      Template projects define <TemplateContent> items to pre-process for token replacements,
      including <ProjectReference> and <PackageVersion> items that define package version replacements.

      All template content files are output into the project's <Content> to ensure the output
      files are added to the template package, and the PackagePath is set to respect ** RecursiveDir
      values to align with <Content> item behavior.

      Template replacement properties are sourced from:
        1. An optional <GeneratedContentProperties> name=value pairs property
        2. All <_TemplatePackageVersionProperty> PackageVersion:ID=VERSION pairs from above
        3. An optional <AdditionalProperty> property on each <TemplateContent> item
    -->
    <GenerateFileFromTemplate
      TemplateFile="%(_ResolvedTemplateContent.Identity)"
      Properties="
        $(GeneratedContentProperties);
        @(_ResolvedTemplatePackageVersion->'PackageVersion:%(Identity)=%(Version)');
        %(_ResolvedTemplateContent.AdditionalProperties)"
      OutputPath="%(_ResolvedTemplateContent.ArtifactPath)" />

    <ItemGroup>
      <!-- Add the generated files into the template package -->
      <Content Include="@(_ResolvedTemplateContent->Metadata('ArtifactPath')->ClearMetadata())">
        <PackagePath>%(_ResolvedTemplateContent.PackagePath)</PackagePath>
      </Content>
    </ItemGroup>
  </Target>

  <Target Name="_ResolveTemplatePackageVersions" DependsOnTargets="ResolveReferences">
    <ItemGroup>
      <!--
        Seed the list with all <ProjectReference> package versions, which depends
        on "ResolveReferences" to invoke the "GetProjectPackageVersion" target.
      -->
      <_ResolvedTemplatePackageVersion Include="@(ProjectPackageVersion)" />

      <!-- Override with the any <PackageVersion> items -->
      <_ResolvedTemplatePackageVersion Remove="@(PackageVersion)" />
      <_ResolvedTemplatePackageVersion Include="@(PackageVersion)" />
    </ItemGroup>
  </Target>

  <Target Name="_ResolveTemplateContentPaths">
    <PropertyGroup>
      <_GeneratedContentDir>$([System.IO.Path]::Combine($(ArtifactsDir), 'ProjectTemplates', $(PackageId), 'GeneratedContent'))</_GeneratedContentDir>
    </PropertyGroup>

    <ItemGroup>
      <_TemplateContentFile Include="@(TemplateContent)">
        <OutputFileName Condition="'%(TemplateContent.ChangeExtension)' == ''">%(FileName)%(TemplateContent.Extension)</OutputFileName>
        <OutputFileName Condition="'%(TemplateContent.ChangeExtension)' != ''">%(FileName)%(TemplateContent.ChangeExtension)</OutputFileName>

        <PackagePathRoot Condition="'%(TemplateContent.PackagePath)' == ''">$([System.IO.Path]::Combine("content", %(TemplateContent.RelativeDir)))</PackagePathRoot>
        <PackagePathRoot Condition="'%(TemplateContent.PackagePath)' != ''">%(TemplateContent.PackagePath)</PackagePathRoot>
      </_TemplateContentFile>

      <_ResolvedTemplateContent Include="@(_TemplateContentFile)">
        <ArtifactPath>$([System.IO.Path]::Combine($(_GeneratedContentDir), %(_TemplateContentFile.RelativeDir), %(_TemplateContentFile.OutputFileName)))</ArtifactPath>
        <PackagePath>$([System.IO.Path]::Combine(%(_TemplateContentFile.PackagePathRoot), %(_TemplateContentFile.RecursiveDir), %(_TemplateContentFile.OutputFileName)))</PackagePath>
      </_ResolvedTemplateContent>
    </ItemGroup>
  </Target>

</Project>
