<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="GenerateStronglyTypedLoggingMethod" xml:space="preserve">
    <value>Generate a strongly-typed logging method</value>
  </data>
  <data name="LegacyLoggingDescription" xml:space="preserve">
    <value>Identifies calls to legacy logging methods</value>
  </data>
  <data name="LegacyLoggingMessage" xml:space="preserve">
    <value>Use source generated logging methods for improved performance</value>
  </data>
  <data name="LegacyLoggingTitle" xml:space="preserve">
    <value>Use source generated logging methods for improved performance</value>
  </data>
  <data name="UsingToStringInLoggersDescription" xml:space="preserve">
    <value>Identifies calls to the 'ToString' method as arguments to a logging method</value>
  </data>
  <data name="UsingToStringInLoggersMessage" xml:space="preserve">
    <value>Provide a logging method that accepts an instance of the object instead of a string</value>
  </data>
  <data name="UsingToStringInLoggersTitle" xml:space="preserve">
    <value>Perform message formatting in the body of the logging method</value>
  </data>
  <data name="StaticTimeDescription" xml:space="preserve">
    <value>Identifies uses of time dependent APIs that can lead to flaky tests</value>
  </data>
  <data name="StaticTimeMessage" xml:space="preserve">
    <value>Use 'System.TimeProvider' to make the code easier to test</value>
  </data>
  <data name="StaticTimeTitle" xml:space="preserve">
    <value>Use 'System.TimeProvider' to make the code easier to test</value>
  </data>
  <data name="SequentialFixAllFormat" xml:space="preserve">
    <value>Apply code fix for all issues in '{0}' '{1}'</value>
  </data>
  <data name="SequentialFixAllInSolution" xml:space="preserve">
    <value>Apply code fix for all issues in current solution</value>
  </data>
  <data name="StartsEndsWithDescription" xml:space="preserve">
    <value>When checking for a single character, prefer the character overloads of 'String.StartsWith' and 'String.EndsWith' for improved performance</value>
  </data>
  <data name="StartsEndsWithMessage" xml:space="preserve">
    <value>Use the character-based overload of '{0}'</value>
  </data>
  <data name="StartsEndsWithTitle" xml:space="preserve">
    <value>Use the character-based overloads of 'String.StartsWith' or 'String.EndsWith'</value>
  </data>
  <data name="MakeExeTypesInternalDescription" xml:space="preserve">
    <value>Making an executable's types internal enables dead code analysis along with other potential optimizations</value>
  </data>
  <data name="MakeExeTypesInternalMessage" xml:space="preserve">
    <value>Make type '{0}' internal since it is declared in an executable</value>
  </data>
  <data name="MakeExeTypesInternalTitle" xml:space="preserve">
    <value>Make types declared in an executable internal</value>
  </data>
  <data name="ArraysDescription" xml:space="preserve">
    <value>Dictionaries and sets which use enums and bytes as keys can often be replaced with simple arrays for improved performance</value>
  </data>
  <data name="ArraysMessage" xml:space="preserve">
    <value>Consider using '{0}?[]' instead of '{1}'</value>
  </data>
  <data name="ArraysTitle" xml:space="preserve">
    <value>Consider using an array instead of a collection</value>
  </data>
  <data name="EnumStringsDescription" xml:space="preserve">
    <value>Replace uses of 'Enum.GetName' and 'Enum.ToString' for improved performance</value>
  </data>
  <data name="EnumStringsTitle" xml:space="preserve">
    <value>Replace uses of 'Enum.GetName' and 'Enum.ToString' for improved performance</value>
  </data>
  <data name="EnumStringsMessage" xml:space="preserve">
    <value>Use {0} instead of '{1}' for improved performance</value>
  </data>
  <data name="ValueTupleDescription" xml:space="preserve">
    <value>Using 'System.ValueTuple' avoids allocations and is generally more efficient than 'System.Tuple'</value>
  </data>
  <data name="ValueTupleMessage" xml:space="preserve">
    <value>Use 'System.ValueTuple' instead of 'System.Tuple' for improved performance</value>
  </data>
  <data name="ValueTupleTitle" xml:space="preserve">
    <value>Use 'System.ValueTuple' instead of 'System.Tuple' for improved performance</value>
  </data>
  <data name="MakeTypeInternal" xml:space="preserve">
    <value>Make the type internal</value>
  </data>
  <data name="LegacyCollectionDescription" xml:space="preserve">
    <value>Using generic collections can avoid boxing overhead and provides strong typing</value>
  </data>
  <data name="LegacyCollectionMessage" xml:space="preserve">
    <value>Use generic collections instead of legacy collections for improved performance</value>
  </data>
  <data name="LegacyCollectionTitle" xml:space="preserve">
    <value>Use generic collections instead of legacy collections for improved performance</value>
  </data>
  <data name="SplitDescription" xml:space="preserve">
    <value>Use 'System.MemoryExtensions.Split' for improved performance</value>
  </data>
  <data name="SplitMessage" xml:space="preserve">
    <value>Use 'System.MemoryExtensions.Split' for improved performance</value>
  </data>
  <data name="SplitTitle" xml:space="preserve">
    <value>Use 'System.MemoryExtensions.Split' for improved performance</value>
  </data>
  <data name="AsyncCallInsideUsingBlockDescription" xml:space="preserve">
    <value>When skipping the await keyword for asynchronous operations inside a using block, then a disposable object could be disposed before the asynchronous invocation finishes. This might result in incorrect behavior and very often ends with a runtime exception notifying that the code is trying to operate on a disposed object.</value>
  </data>
  <data name="AsyncCallInsideUsingBlockMessage" xml:space="preserve">
    <value>Async call should be awaited before leaving the 'using' block</value>
  </data>
  <data name="AsyncCallInsideUsingBlockTitle" xml:space="preserve">
    <value>Fire-and-forget async call inside a 'using' block</value>
  </data>
  <data name="ConditionalAccessDescription" xml:space="preserve">
    <value>Using the conditional access operator (?) to access values which are statically known not to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="ConditionalAccessMessage" xml:space="preserve">
    <value>Consider removing unnecessary conditional access operator (?) since the value is statically known not to be null</value>
  </data>
  <data name="ConditionalAccessTitle" xml:space="preserve">
    <value>Consider removing unnecessary conditional access operator (?)</value>
  </data>
  <data name="CoalesceAssignmentDescription" xml:space="preserve">
    <value>Using the null coalescing assignment operator (??=) with values which are statically known not to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="CoalesceAssignmentMessage" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing assignment (??=) since the target value is statically known not to be null</value>
  </data>
  <data name="CoalesceAssignmentTitle" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing assignment (??=)</value>
  </data>
  <data name="CoalesceDescription" xml:space="preserve">
    <value>Using the null coalescing operator (??) with values which are statically known to be null causes superfluous null checks to be performed at runtime</value>
  </data>
  <data name="CoalesceMessage" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing (??) since the left-hand value is statically known not to be null</value>
  </data>
  <data name="CoalesceTitle" xml:space="preserve">
    <value>Consider removing unnecessary null coalescing operator (??)</value>
  </data>
  <data name="AsyncMethodWithoutCancellationDescription" xml:space="preserve">
    <value>Accepting a CancellationToken as a parameter allows caller to express a loss of interest in the result enabling the method to save cycles by finishing early</value>
  </data>
  <data name="AsyncMethodWithoutCancellationMessage" xml:space="preserve">
    <value>Add CancellationToken as the parameter of asynchronous method</value>
  </data>
  <data name="AsyncMethodWithoutCancellationTitle" xml:space="preserve">
    <value>The async method doesn't support cancellation</value>
  </data>
</root>